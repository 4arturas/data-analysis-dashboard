<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dynamic Grafana Requests Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/utc.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/timezone.js"></script>

    <script>
        if (typeof dayjs !== 'undefined' && typeof dayjs.extend === 'function') {
            if (typeof dayjs_plugin_utc === 'function') {
                dayjs.extend(dayjs_plugin_utc);
            }
            if (typeof dayjs_plugin_timezone === 'function') {
                dayjs.extend(dayjs_plugin_timezone);
            }
        }
    </script>

    <link href="https://cdnjs.cloudflare.com/ajax/libs/antd/5.27.5/reset.css" rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/antd/5.27.4/antd.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts-gl@2.0.9/dist/echarts-gl.min.js"></script>

    <script type="text/babel" src="components/Context.js"></script>
    <script type="text/babel" src="components/algorithms.js"></script>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useMemo } = React;
        const {
            Button,
            Space,
            Typography,
            DatePicker,
            Tabs,
            Spin,
            Table,
            Slider,
            Select,
            Modal
        } = antd;
        const { Text } = Typography;
        const { RangePicker } = DatePicker;
    </script>
    <script type="text/babel">
        function CorrelationTable({ data, loading, correlationThreshold, onThresholdChange, allCorrelations, onShowChart, onTableChange, sortInfo }) {
            if (loading) {
                return (
                    <div style={{ padding: '20px', textAlign: 'center', marginTop: '20px', border: '1px solid #eee', height: '500px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                        <antd.Spin size="large" tip="Calculating Correlations..." />
                    </div>
                );
            }

            const columns = [
                {
                    title: 'Series A',
                    dataIndex: 'seriesA',
                    key: 'seriesA',
                    render: (text, record) => (
                        <>
                            <Text strong>{record.payloadKeyA}</Text>
                            <br />
                            <Text type="secondary" style={{ fontSize: '0.85em' }}>{text}</Text>
                        </>
                    )
                },
                {
                    title: 'Series B',
                    dataIndex: 'seriesB',
                    key: 'seriesB',
                    render: (text, record) => (
                        <>
                            <Text strong>{record.payloadKeyB}</Text>
                            <br />
                            <Text type="secondary" style={{ fontSize: '0.85em' }}>{text}</Text>
                        </>
                    )
                },
                {
                    title: 'R-Value',
                    dataIndex: 'rValue',
                    key: 'rValue',
                    render: (text) => {
                        const value = text;
                        const formattedText = value.toFixed(4);
                        let color = 'black';
                        if (value > 0) {
                            color = 'green';
                        } else if (value < 0) {
                            color = 'red';
                        }
                        return <Text strong style={{ color: color }}>{formattedText}</Text>;
                    },
                    sorter: (a, b) => a.rValue - b.rValue,
                },
                {
                    title: 'Chart',
                    key: 'chart',
                    render: (text, record) => (
                        <a onClick={() => onShowChart(record)}>ðŸ“ˆ</a>
                    ),
                },
            ];

            const hasCorrelations = allCorrelations.length > 0;

            return (
                <div style={{ marginTop: '20px' }}>
                    <div style={{ minWidth: 250, marginBottom: '10px' }}>
                        <Text strong>Correlation Threshold (|R| &le; {correlationThreshold.toFixed(2)}):</Text>
                        <antd.Slider
                            min={0.05}
                            max={1.0}
                            step={0.01}
                            value={correlationThreshold}
                            onChange={onThresholdChange}
                            tooltip={{ formatter: (value) => `|R| \u2264 ${value.toFixed(2)}` }}
                            disabled={!hasCorrelations}
                        />
                    </div>
                    <antd.Table
                        dataSource={data}
                        columns={columns}
                        pagination={false}
                        size="small"
                        style={{ marginTop: '10px' }}
                        onChange={onTableChange}
                        locale={{
                            emptyText: hasCorrelations
                                ? `No correlations found with |R| \u2264 ${correlationThreshold.toFixed(2)}`
                                : 'Not enough data to calculate correlations (need at least two series).'
                        }}
                    />
                </div>
            );
        }
    </script>
    <script type="text/babel">
        function EChartsVisualization({ data, yAxisName = 'Value', loading = false }) {
            const chartRef = React.useRef(null);
            const chartInstance = React.useRef(null);

            useEffect(() => {
                if (!chartRef.current || loading || data.length === 0) return;

                if (chartInstance.current) {
                    chartInstance.current.dispose();
                }

                const chart = echarts.init(chartRef.current);
                chartInstance.current = chart;

                const seriesData = data.map(series => ({
                    name: series.name,
                    type: 'line',
                    data: series.data,
                    showSymbol: false,
                }));

                const option = {
                    tooltip: {
                        trigger: 'axis',
                        formatter: function (params) {
                            let result = dayjs(params[0].value[0]).format('YYYY-MM-DD HH:mm:ss');
                            params.forEach(function (item) {
                                const value = item.value[1];
                                const formattedValue = typeof value === 'number' ? value.toFixed(4) : value;
                                result += '<br/>' + item.marker + item.seriesName + ': ' + formattedValue;
                            });
                            return result;
                        }
                    },
                    legend: {
                        data: data.map(d => d.name),
                        type: 'scroll',
                        bottom: 30,
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'time',
                        name: 'Time',
                    },
                    yAxis: {
                        type: 'value',
                        name: yAxisName,
                    },
                    series: seriesData,
                    dataZoom: [
                        {
                            type: 'inside',
                            xAxisIndex: 0,
                            start: 0,
                            end: 100,
                        },
                        {
                            type: 'slider',
                            xAxisIndex: 0,
                            start: 0,
                            end: 100,
                            height: 20,
                            bottom: 5,
                        }
                    ]
                };

                chart.setOption(option);

                const resizeObserver = new ResizeObserver(() => chart.resize());
                resizeObserver.observe(chartRef.current);

                return () => {
                    resizeObserver.disconnect();

                    if (chartInstance.current) {
                        chartInstance.current.dispose();
                        chartInstance.current = null;
                    }
                };
            }, [data, yAxisName, loading]);

            if (loading) {
                return (
                    <div style={{ padding: '20px', textAlign: 'center', marginTop: '20px', border: '1px solid #eee', height: '500px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                        <antd.Spin size="large" tip="Fetching Data..." />
                    </div>
                );
            }

            if (data.length === 0) {
                return (
                    <div style={{ padding: '20px', textAlign: 'center', color: '#888', marginTop: '20px' }}>
                        No series data available to display.
                    </div>
                );
            }

            return (
                <div
                    ref={chartRef}
                    style={{ width: '100%', height: '500px', border: '1px solid #eee', marginTop: '20px' }}
                />
            );
        }
    </script>
    <script type="text/babel">
    function DTWVisualization({ series1, series2, dtwResult, loading }) {
        const chartRef = React.useRef(null);
        const chartInstance = React.useRef(null);

        useEffect(() => {
            if (!chartRef.current || loading || !series1 || !series2 || !dtwResult) return;

            if (chartInstance.current) {
                chartInstance.current.dispose();
            }

            const chart = echarts.init(chartRef.current);
            chartInstance.current = chart;

            const option = {
                title: {
                    text: `DTW Distance: ${dtwResult.distance.toFixed(4)}`,
                    left: 'center',
                },
                tooltip: {
                    trigger: 'axis',
                    formatter: function (params) {
                        let result = `Index: ${params[0].axisValueLabel}<br/>`;
                        params.forEach(function (item) {
                            result += `${item.marker}${item.seriesName}: ${item.value[1].toFixed(4)}<br/>`;
                        });
                        return result;
                    }
                },
                legend: {
                    data: [series1.name, series2.name, 'Warping Path'],
                    bottom: 30,
                },
                grid: {
                    left: '5%',
                    right: '5%',
                    bottom: '15%',
                    containLabel: true,
                },
                xAxis: {
                    type: 'value',
                    name: 'Time (index)',
                    boundaryGap: false,
                },
                yAxis: {
                    type: 'value',
                    name: 'Normalized Value',
                },
                series: [
                    {
                        name: series1.name,
                        type: 'line',
                        data: series1.data.map((d, i) => [i, d[1]]),
                        showSymbol: false,
                    },
                    {
                        name: series2.name,
                        type: 'line',
                        data: series2.data.map((d, i) => [i, d[1]]),
                        showSymbol: false,
                    },
                    {
                        name: 'Warping Path',
                        type: 'lines',
                        data: dtwResult.path.map(p => ({
                            coords: [
                                [p[0], series1.data[p[0]][1]],
                                [p[1], series2.data[p[1]][1]]
                            ]
                        })),
                        lineStyle: {
                            color: 'rgba(0, 0, 0, 0.2)',
                            width: 1,
                        }
                    }
                ],
                dataZoom: [
                    {
                        type: 'inside',
                        start: 0,
                        end: 100,
                    },
                    {
                        type: 'slider',
                        height: 20,
                        bottom: 5,
                    }
                ]
            };

            chart.setOption(option);

            const resizeObserver = new ResizeObserver(() => chart.resize());
            resizeObserver.observe(chartRef.current);

            return () => {
                resizeObserver.disconnect();
                if (chartInstance.current) {
                    chartInstance.current.dispose();
                    chartInstance.current = null;
                }
            };
        }, [series1, series2, dtwResult, loading]);

        if (loading) {
            return (
                <div style={{ padding: '20px', textAlign: 'center', marginTop: '20px', border: '1px solid #eee', height: '500px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                    <antd.Spin size="large" tip="Calculating DTW..." />
                </div>
            );
        }
        
        if (!series1 || !series2) {
             return (
                <div style={{ padding: '20px', textAlign: 'center', color: '#888', marginTop: '20px' }}>
                    Please select two series to compare.
                </div>
            );
        }

        if (!dtwResult) {
            return (
                <div style={{ padding: '20px', textAlign: 'center', color: '#888', marginTop: '20px' }}>
                    Calculating DTW...
                </div>
            );
        }

        return (
            <div
                ref={chartRef}
                style={{ width: '100%', height: '500px', border: '1px solid #eee', marginTop: '20px' }}
            />
        );
    }

    function DTWSimilarityTable({ series1, series2, dtwResult }) {
        if (!series1 || !series2 || !dtwResult) {
            return null;
        }

        const similarityScore = 1 / (1 + dtwResult.distance);

        const columns = [
            {
                title: 'Metric',
                dataIndex: 'metric',
                key: 'metric',
            },
            {
                title: 'Value',
                dataIndex: 'value',
                key: 'value',
            },
        ];

        const data = [
            {
                key: '1',
                metric: 'DTW Distance',
                value: dtwResult.distance.toFixed(4),
            },
            {
                key: '2',
                metric: 'Similarity Score',
                value: similarityScore.toFixed(4),
            },
        ];

        return (
            <div style={{ marginTop: '20px' }}>
                <antd.Table
                    dataSource={data}
                    columns={columns}
                    pagination={false}
                    size="small"
                />
            </div>
        );
    }
    
    function DTW({ normalizedChartsData, loading }) {
        const [series1, setSeries1] = useState(null);
        const [series2, setSeries2] = useState(null);
        const [dtwResult, setDtwResult] = useState(null);
        
        const handleSeries1Change = (value) => {
            const selectedSeries = normalizedChartsData.find(s => s.name === value);
            setSeries1(selectedSeries);
        };

        const handleSeries2Change = (value) => {
            const selectedSeries = normalizedChartsData.find(s => s.name === value);
            setSeries2(selectedSeries);
        };
        
        useEffect(() => {
            if (series1 && series2) {
                const dtwResult = calculateDTW(series1.data.map(d => d[1]), series2.data.map(d => d[1]));
                setDtwResult(dtwResult);
            } else {
                setDtwResult(null);
            }
        }, [series1, series2]);

        return (
            <div>
                <Space>
                    <antd.Select
                        showSearch
                        style={{ width: 300 }}
                        placeholder="Select Series 1"
                        onChange={handleSeries1Change}
                        filterOption={(input, option) =>
                            option.children.toLowerCase().indexOf(input.toLowerCase()) >= 0
                        }
                    >
                        {normalizedChartsData.map(series => (
                            <antd.Select.Option key={series.name} value={series.name}>{series.name}</antd.Select.Option>
                        ))}
                    </antd.Select>
                    <antd.Select
                        showSearch
                        style={{ width: 300 }}
                        placeholder="Select Series 2"
                        onChange={handleSeries2Change}
                        filterOption={(input, option) =>
                            option.children.toLowerCase().indexOf(input.toLowerCase()) >= 0
                        }
                    >
                        {normalizedChartsData.map(series => (
                            <antd.Select.Option key={series.name} value={series.name}>{series.name}</antd.Select.Option>
                        ))}
                    </antd.Select>
                </Space>
                <DTWVisualization
                    series1={series1}
                    series2={series2}
                    dtwResult={dtwResult}
                    loading={loading}
                />
                <DTWSimilarityTable
                    series1={series1}
                    series2={series2}
                    dtwResult={dtwResult}
                />
            </div>
        );
    }
</script>
    <script type="text/babel">
        function MainApp() {
            const API_URL = '/run-request';

            const { appContext, setAppContext } = React.useContext(AppContext);

            const initialFrom = appContext.initialFrom;
            const initialTo = appContext.initialTo;
            const loading = appContext.loading;
            const correlationThreshold = appContext.correlationThreshold;
            const allCorrelations = appContext.allCorrelations;
            
            const [modalVisible, setModalVisible] = useState(false);
            const [modalChartData, setModalChartData] = useState([]);

            const [sortInfo, setSortInfo] = useState({ order: 'descend', columnKey: 'rValue' });

            const handleTableChange = (pagination, filters, sorter) => {
                setSortInfo(sorter);
            };

            const handleShowChart = (record) => {
                const seriesA = appContext.rawChartsData.find(s => s.name === record.seriesA);
                const seriesB = appContext.rawChartsData.find(s => s.name === record.seriesB);
                setModalChartData([seriesA, seriesB]);
                setModalVisible(true);
            };

            const handleCancelModal = () => {
                setModalVisible(false);
            };

            // Use useMemo for instant, correct filtering of the correlation data
            const correlationData = useMemo(() => {
                if (!allCorrelations || allCorrelations.length === 0) {
                    return [];
                }
                // THIS IS THE CORRECT FILTERING LOGIC: |R| >= Threshold
                return allCorrelations.filter(item =>
                    Math.abs(item.rValue) >= correlationThreshold
                );
            }, [allCorrelations, correlationThreshold]);


            const [dateRange, setDateRange] = useState([
                dayjs.tz(initialFrom.replace('Z', ''), 'Europe/Vilnius'),
                dayjs.tz(initialTo.replace('Z', ''), 'Europe/Vilnius')
            ]);

            const handleDateChange = (dates) => {
                if (dates && dates.length === 2 && dates[0] && dates[1]) {
                    setDateRange(dates);
                } else {
                    setDateRange([null, null]);
                }
            };

            const handleThresholdChange = (value) => {
                setAppContext(prevContext => ({
                    ...prevContext,
                    correlationThreshold: value
                }));
            };

            const runRequests = useCallback(async (startDayjs, endDayjs) => {
                if (!startDayjs || !endDayjs) return;

                setAppContext(prevContext => ({
                    ...prevContext,
                    loading: true,
                    rawChartsData: [],
                    normalizedChartsData: [],
                    allCorrelations: [],
                }));

                const fromISO = startDayjs.toISOString();
                const toISO = endDayjs.toISOString();

                try {
                    const newRawChartsData = [];

                    const response = await fetch('./payload.json');
                    // Assume payloads.json is now an object map to support payload keys
                    const basePayloads = await response.json();

                    setAppContext(prevContext => ({ ...prevContext, payloads: basePayloads }));

                    const payloadEntries = Object.entries(basePayloads);

                    for (let i = 0; i < payloadEntries.length; i++) {
                        const [payloadKey, payload] = payloadEntries[i]; // Get key and payload

                        const response = await fetch(API_URL, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ from: fromISO, to: toISO, payload })
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }

                        const data = await response.json();
                        const frames = data.data.results.A.frames;

                        for (const frame of frames) {
                            const x = frame.data.values[0];
                            const y = frame.data.values[1];
                            const name = frame.schema.name;

                            const seriesData = x.map((ts, index) => {
                                const timestamp = !isNaN(ts) ? Number(ts) : dayjs(ts).valueOf();
                                return [timestamp, y[index]];
                            });

                            newRawChartsData.push({
                                name: name,
                                payloadKey: payloadKey, // Store the payload key
                                data: seriesData
                            });
                        }
                    }

                    const newNormalizedChartsData = normalizeData(newRawChartsData);
                    const allCorrelationData = calculateAllCorrelations(newRawChartsData);

                    // Set all results to context. Filtered results are calculated by useMemo immediately after.
                    setAppContext(prevContext => ({
                        ...prevContext,
                        rawChartsData: newRawChartsData,
                        normalizedChartsData: newNormalizedChartsData,
                        allCorrelations: allCorrelationData,
                    }));

                } catch (err) {
                    console.error("Data Fetch Error:", err.message);
                } finally {
                    setAppContext(prevContext => ({ ...prevContext, loading: false }));
                }
            }, [setAppContext]);

            useEffect(() => {
                const [start, end] = dateRange;
                if (start && end) {
                    runRequests(start, end);
                }
            }, []);

            const handleRunClick = () => {
                const [start, end] = dateRange;
                runRequests(start, end);
            }

            const rawChartsData = appContext.rawChartsData;
            const normalizedChartsData = appContext.normalizedChartsData;

            const tabsItems = [
                {
                    key: '1',
                    label: 'Raw Data',
                    children: (
                        <EChartsVisualization
                            data={rawChartsData}
                            yAxisName="Value"
                            loading={loading}
                        />
                    ),
                },
                {
                    key: '2',
                    label: 'Normalized Data',
                    children: (
                        <EChartsVisualization
                            data={normalizedChartsData}
                            yAxisName="Normalized Value (0 to 1)"
                            loading={loading}
                        />
                    ),
                },
                {
                    key: '3',
                    label: 'R-Values (Correlation)',
                    children: (
                        <CorrelationTable
                            data={correlationData} // Pass the instantly filtered data
                            loading={loading}
                            correlationThreshold={correlationThreshold}
                            onThresholdChange={handleThresholdChange}
                            allCorrelations={allCorrelations}
                            onShowChart={handleShowChart}
                            onTableChange={handleTableChange}
                            sortInfo={sortInfo}
                        />
                    ),
                },
                {
                    key: '4',
                    label: 'Dynamic Time Warping',
                    children: (
                        <DTW
                            normalizedChartsData={normalizedChartsData}
                            loading={loading}
                        />
                    ),
                }
            ];

            return (
                <div style={{ padding: '20px' }}>
                    <Space direction="horizontal" style={{ marginBottom: '20px', alignItems: 'flex-start', flexWrap: 'wrap' }}>
                        <div style={{ minWidth: 400 }}>
                            <Text strong>Select Period (Vilnius Time):</Text><br />
                            <RangePicker
                                value={dateRange}
                                showTime={{ format: 'HH:mm:ss' }}
                                format="YYYY-MM-DD HH:mm:ss"
                                onChange={handleDateChange}
                                style={{ width: '100%' }}
                            />
                        </div>
                        <div>
                            <Button
                                type="primary"
                                onClick={handleRunClick}
                                disabled={loading || !dateRange[0] || !dateRange[1]}
                                style={{ marginTop: 27 }}
                            >
                                {loading ? 'Fetching Data...' : 'Refresh Data'}
                            </Button>
                        </div>
                    </Space>

                    <Tabs
                        defaultActiveKey="1"
                        items={tabsItems}
                    />
                    
                    <antd.Modal
                        title="Correlated Series Chart"
                        open={modalVisible}
                        onCancel={handleCancelModal}
                        footer={null}
                        width="80%"
                    >
                        <EChartsVisualization
                            data={modalChartData}
                            yAxisName="Value"
                            loading={false}
                        />
                    </antd.Modal>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(
            React.createElement(AppProvider, null, React.createElement(MainApp))
        );
    </script>
</body>

</html>
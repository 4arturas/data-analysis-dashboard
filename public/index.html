<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dynamic Grafana Requests Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/utc.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/timezone.js"></script>

    <script>
        if (typeof dayjs !== 'undefined' && typeof dayjs.extend === 'function') {
            if (typeof dayjs_plugin_utc === 'function') {
                dayjs.extend(dayjs_plugin_utc);
            }
            if (typeof dayjs_plugin_timezone === 'function') {
                dayjs.extend(dayjs_plugin_timezone);
            }
        }
    </script>

    <link href="https://cdnjs.cloudflare.com/ajax/libs/antd/5.27.5/reset.css" rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/antd/5.27.4/antd.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts-gl@2.0.9/dist/echarts-gl.min.js"></script>

    <script type="text/babel">
const { createContext, useState } = React;

const AppContext = createContext({});

const AppProvider = ({ children }) => {
    const [appContext, setAppContext] = useState({
        activeTabKey: '1',
        payloads: [],
        rawChartsData: [],
        normalizedChartsData: [], // Added for correlation analysis
        allCorrelations: [], // Added for correlation analysis (unfiltered source)
        normalizeDataForCorrelation: true,


        initialFrom: '2025-11-10T10:40:00.000Z',
        initialTo: '2025-11-10T11:10:00.000Z',

        // initialFrom: '2025-11-10T00:00:00.000Z',
        // initialTo: '2025-11-10T23:59:59.000Z',

        // initialFrom: '2025-11-10T10:00:00.000Z',
        // initialTo: '2025-11-10T11:00:00.000Z',
    });

    const contextValue = {
        appContext,
        setAppContext,
    };

    return (
        <AppContext.Provider value={contextValue}>
            {children}
        </AppContext.Provider>
    );
};
    </script>
    <script type="text/babel">
const normalizeData = (rawChartsData) => {
    if (!rawChartsData || rawChartsData.length === 0) {
        return [];
    }

    const normalizedData = [];

    rawChartsData.forEach(series => {
        let min = Infinity;
        let max = -Infinity;

        series.data.forEach(point => {
            const value = point[1];
            if (typeof value === 'number' && !isNaN(value)) {
                if (value < min) min = value;
                if (value > max) max = value;
            }
        });

        const range = max - min;
        const normalizedSeriesData = series.data.map(point => {
            const timestamp = point[0];
            const value = point[1];
            let normalizedValue = value;

            if (typeof value === 'number' && !isNaN(value)) {
                if (range === 0) {
                    normalizedValue = 0;
                } else {
                    normalizedValue = (value - min) / range;
                }
            }
            return [timestamp, normalizedValue];
        });

        normalizedData.push({
            name: series.name,
            payloadKey: series.payloadKey,
            data: normalizedSeriesData
        });
    });

    return normalizedData;
}

const calculateAllCorrelations = (chartsData) => {
    const correlations = [];
    const n = chartsData.length;

    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            const dtwResult = calculateDTW(
                chartsData[i].data.map(d => d[1]),
                chartsData[j].data.map(d => d[1])
            );
            correlations.push({
                key: `${chartsData[i].name}-${chartsData[j].name}`,
                seriesA: chartsData[i].name,
                seriesB: chartsData[j].name,
                payloadKeyA: chartsData[i].payloadKey,
                payloadKeyB: chartsData[j].payloadKey,
                dtwDistance: dtwResult.distance
            });
        }
    }
    return correlations;
}

const calculateDTW = (ts1, ts2, distanceFunction = (a, b) => Math.abs(a - b)) => {
    const n = ts1.length;
    const m = ts2.length;

    if (n === 0 && m === 0) {
        return { distance: 0, path: [] };
    }
    if (n === 0 || m === 0) {
        return { distance: Infinity, path: [] };
    }

    const dtw = Array(n).fill(null).map(() => Array(m).fill(Infinity));
    dtw[0][0] = distanceFunction(ts1[0], ts2[0]);

    for (let i = 1; i < n; i++) {
        dtw[i][0] = distanceFunction(ts1[i], ts2[0]) + dtw[i - 1][0];
    }

    for (let j = 1; j < m; j++) {
        dtw[0][j] = distanceFunction(ts1[0], ts2[j]) + dtw[0][j - 1];
    }

    for (let i = 1; i < n; i++) {
        for (let j = 1; j < m; j++) {
            const cost = distanceFunction(ts1[i], ts2[j]);
            dtw[i][j] = cost + Math.min(dtw[i - 1][j], dtw[i][j - 1], dtw[i - 1][j - 1]);
        }
    }

    let path = [];
    let i = n - 1;
    let j = m - 1;
    path.push([i, j]);

    while (i > 0 || j > 0) {
        if (i > 0 && j > 0) {
            const min = Math.min(dtw[i - 1][j], dtw[i][j - 1], dtw[i - 1][j - 1]);
            if (min === dtw[i - 1][j - 1]) {
                i--;
                j--;
            } else if (min === dtw[i - 1][j]) {
                i--;
            } else {
                j--;
            }
        } else if (i > 0) {
            i--;
        } else {
            j--;
        }
        path.push([i, j]);
    }
    path.reverse();

    return {
        distance: dtw[n - 1][m - 1],
        path: path,
    };
}
    </script>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useMemo } = React;
        const {
            Button,
            Space,
            Typography,
            DatePicker,
            Tabs,
            Spin,
            Table,
            Slider,
            Select,
            Modal
        } = antd;
        const { Text } = Typography;
        const { RangePicker } = DatePicker;
    </script>
    <script type="text/babel">
        function CorrelationTable({ data, loading, onShowChart, onTableChange, sortInfo, normalizationType }) {
            if (loading) {
                return (
                    <div style={{ padding: '20px', textAlign: 'center', marginTop: '20px', border: '1px solid #eee', height: '500px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                        <antd.Spin size="large" tip="Calculating Correlations..." />
                    </div>
                );
            }

            const columns = [
                {
                    title: `Series A (${normalizationType})`,
                    dataIndex: 'seriesA',
                    key: 'seriesA',
                    render: (text, record) => (
                        <>
                            <Text strong>{record.payloadKeyA}</Text>
                            <br />
                            <Text type="secondary" style={{ fontSize: '0.85em' }}>{text}</Text>
                        </>
                    )
                },
                {
                    title: `Series B (${normalizationType})`,
                    dataIndex: 'seriesB',
                    key: 'seriesB',
                    render: (text, record) => (
                        <>
                            <Text strong>{record.payloadKeyB}</Text>
                            <br />
                            <Text type="secondary" style={{ fontSize: '0.85em' }}>{text}</Text>
                        </>
                    )
                },
                {
                    title: 'DTW Distance',
                    dataIndex: 'dtwDistance',
                    key: 'dtwDistance',
                    render: (text) => text.toFixed(4),
                    sorter: (a, b) => a.dtwDistance - b.dtwDistance,
                },
                {
                    title: 'Chart',
                    key: 'chart',
                    render: (text, record) => (
                        <a onClick={() => onShowChart(record, normalizationType)}>ðŸ“ˆ</a>
                    ),
                },
            ];

            const hasCorrelations = data.length > 0;

            return (
                <div style={{ marginTop: '20px' }}>
                    <antd.Table
                        dataSource={data}
                        columns={columns}
                        pagination={false}
                        size="small"
                        style={{ marginTop: '10px' }}
                        onChange={onTableChange}
                        locale={{
                            emptyText: data.length > 0
                                ? `No correlations found.`
                                : 'Not enough data to calculate correlations (need at least two series).'
                        }}
                    />
                </div>
            );
        }
    </script>
    <script type="text/babel">
        function EChartsVisualization({ data, yAxisName = 'Value', loading = false }) {
            const chartRef = React.useRef(null);
            const chartInstance = React.useRef(null);

            useEffect(() => {
                if (!chartRef.current || loading || data.length === 0) return;

                if (chartInstance.current) {
                    chartInstance.current.dispose();
                }

                const chart = echarts.init(chartRef.current);
                chartInstance.current = chart;

                const seriesData = data.map(series => ({
                    name: series.name,
                    type: 'line',
                    data: series.data,
                    showSymbol: false,
                }));

                const option = {
                    tooltip: {
                        trigger: 'axis',
                        formatter: function (params) {
                            let result = dayjs(params[0].value[0]).format('YYYY-MM-DD HH:mm:ss');
                            params.forEach(function (item) {
                                const value = item.value[1];
                                const formattedValue = typeof value === 'number' ? value.toFixed(4) : value;
                                result += '<br/>' + item.marker + item.seriesName + ': ' + formattedValue;
                            });
                            return result;
                        }
                    },
                    legend: {
                        data: data.map(d => d.name),
                        type: 'scroll',
                        bottom: 30,
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '15%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'time',
                        name: 'Time',
                    },
                    yAxis: {
                        type: 'value',
                        name: yAxisName,
                    },
                    series: seriesData,
                    dataZoom: [
                        {
                            type: 'inside',
                            xAxisIndex: 0,
                            start: 0,
                            end: 100,
                        },
                        {
                            type: 'slider',
                            xAxisIndex: 0,
                            start: 0,
                            end: 100,
                            height: 20,
                            bottom: 5,
                        }
                    ]
                };

                chart.setOption(option);

                const resizeObserver = new ResizeObserver(() => chart.resize());
                resizeObserver.observe(chartRef.current);

                return () => {
                    resizeObserver.disconnect();

                    if (chartInstance.current) {
                        chartInstance.current.dispose();
                        chartInstance.current = null;
                    }
                };
            }, [data, yAxisName, loading]);

            if (loading) {
                return (
                    <div style={{ padding: '20px', textAlign: 'center', marginTop: '20px', border: '1px solid #eee', height: '500px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                        <antd.Spin size="large" tip="Fetching Data..." />
                    </div>
                );
            }

            if (data.length === 0) {
                return (
                    <div style={{ padding: '20px', textAlign: 'center', color: '#888', marginTop: '20px' }}>
                        No series data available to display.
                    </div>
                );
            }

            return (
                <div
                    ref={chartRef}
                    style={{ width: '100%', height: '500px', border: '1px solid #eee', marginTop: '20px' }}
                />
            );
        }
    </script>
    <script type="text/babel">
        function MainApp() {
            const API_URL = '/run-request';

            const { appContext, setAppContext } = React.useContext(AppContext);

            const initialFrom = appContext.initialFrom;
            const initialTo = appContext.initialTo;
            const loading = appContext.loading;
            const allCorrelationsRaw = appContext.allCorrelationsRaw;
            const allCorrelationsNormalized = appContext.allCorrelationsNormalized;

            const [modalVisible, setModalVisible] = useState(false);
            const [modalChartData, setModalChartData] = useState([]);
            const [modalTitle, setModalTitle] = useState('');

            const [sortInfo, setSortInfo] = useState({ order: 'ascend', columnKey: 'dtwDistance' });

            const [activeCorrelationTabKey, setActiveCorrelationTabKey] = useState('normalized'); // 'normalized' or 'raw'

            const handleTableChange = (pagination, filters, sorter) => {
                setSortInfo(sorter);
            };

            const handleShowChart = (record, normalizationType) => {
                let seriesSource;
                if (normalizationType === "Normalized") {
                    seriesSource = appContext.normalizedChartsData;
                } else {
                    seriesSource = appContext.rawChartsData;
                }

                const seriesA = seriesSource.find(s => s.name === record.seriesA);
                const seriesB = seriesSource.find(s => s.name === record.seriesB);
                setModalChartData([seriesA, seriesB]);
                setModalTitle(`DTW: ${record.dtwDistance.toFixed(4)} | ${record.seriesA} vs ${record.seriesB}`);
                setModalVisible(true);
            };

            const handleCancelModal = () => {
                setModalVisible(false);
            };

            const correlationData = useMemo(() => {
                if (activeCorrelationTabKey === 'normalized') {
                    return allCorrelationsNormalized || [];
                }
                return allCorrelationsRaw || [];
            }, [activeCorrelationTabKey, allCorrelationsRaw, allCorrelationsNormalized]);


            const [dateRange, setDateRange] = useState([
                dayjs.tz(initialFrom.replace('Z', ''), 'Europe/Vilnius'),
                dayjs.tz(initialTo.replace('Z', ''), 'Europe/Vilnius')
            ]);

            const handleDateChange = (dates) => {
                if (dates && dates.length === 2 && dates[0] && dates[1]) {
                    setDateRange(dates);
                } else {
                    setDateRange([null, null]);
                }
            };

            const runRequests = useCallback(async (startDayjs, endDayjs) => {
                if (!startDayjs || !endDayjs) return;

                setAppContext(prevContext => ({
                    ...prevContext,
                    loading: true,
                    rawChartsData: [],
                    normalizedChartsData: [],
                    allCorrelationsRaw: [],
                    allCorrelationsNormalized: [],
                }));

                const fromISO = startDayjs.toISOString();
                const toISO = endDayjs.toISOString();

                try {
                    const newRawChartsData = [];

                    const response = await fetch('./payload.json');
                    // Assume payloads.json is now an object map to support payload keys
                    const basePayloads = await response.json();

                    setAppContext(prevContext => ({ ...prevContext, payloads: basePayloads }));

                    const payloadEntries = Object.entries(basePayloads);

                    for (let i = 0; i < payloadEntries.length; i++) {
                        const [payloadKey, payload] = payloadEntries[i]; // Get key and payload

                        const response = await fetch(API_URL, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ from: fromISO, to: toISO, payload })
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }

                        const data = await response.json();
                        const frames = data.data.results.A.frames;

                        for (const frame of frames) {
                            const x = frame.data.values[0];
                            const y = frame.data.values[1];
                            const name = frame.schema.name;

                            const seriesData = x.map((ts, index) => {
                                const timestamp = !isNaN(ts) ? Number(ts) : dayjs(ts).valueOf();
                                return [timestamp, y[index]];
                            });

                            newRawChartsData.push({
                                name: name,
                                payloadKey: payloadKey, // Store the payload key
                                data: seriesData
                            });
                        }
                    }

                    const newNormalizedChartsData = normalizeData(newRawChartsData);
                    const allCorrelationDataRaw = calculateAllCorrelations(newRawChartsData);
                    const allCorrelationDataNormalized = calculateAllCorrelations(newNormalizedChartsData);


                    setAppContext(prevContext => ({
                        ...prevContext,
                        rawChartsData: newRawChartsData,
                        normalizedChartsData: newNormalizedChartsData,
                        allCorrelationsRaw: allCorrelationDataRaw,
                        allCorrelationsNormalized: allCorrelationDataNormalized,
                    }));

                } catch (err) {
                    console.error("Data Fetch Error:", err.message);
                } finally {
                    setAppContext(prevContext => ({ ...prevContext, loading: false }));
                }
            }, [setAppContext]);

            useEffect(() => {
                const [start, end] = dateRange;
                if (start && end) {
                    runRequests(start, end);
                }
            }, []);

            const handleRunClick = () => {
                const [start, end] = dateRange;
                runRequests(start, end);
            }

            const rawChartsData = appContext.rawChartsData;
            const normalizedChartsData = appContext.normalizedChartsData;

            const tabsItems = [
                {
                    key: '1',
                    label: 'Normalized Correlation Analysis',
                    children: (
                        <CorrelationTable
                            data={correlationData}
                            loading={loading}
                            onShowChart={handleShowChart}
                            onTableChange={handleTableChange}
                            sortInfo={sortInfo}
                            normalizationType="Normalized"
                        />
                    ),
                },
                {
                    key: '2',
                    label: 'Raw Correlation Analysis',
                    children: (
                        <CorrelationTable
                            data={correlationData}
                            loading={loading}
                            onShowChart={handleShowChart}
                            onTableChange={handleTableChange}
                            sortInfo={sortInfo}
                            normalizationType="Raw"
                        />
                    ),
                },
                {
                    key: '3',
                    label: 'Raw Data',
                    children: (
                        <EChartsVisualization
                            data={rawChartsData}
                            yAxisName="Value"
                            loading={loading}
                        />
                    ),
                },
                {
                    key: '4',
                    label: 'Normalized Data',
                    children: (
                        <EChartsVisualization
                            data={normalizedChartsData}
                            yAxisName="Normalized Value (0 to 1)"
                            loading={loading}
                        />
                    ),
                },
            ];

            return (
                <div style={{ padding: '20px' }}>
                    <Space direction="horizontal" style={{ marginBottom: '20px', alignItems: 'flex-start', flexWrap: 'wrap' }}>
                        <div style={{ minWidth: 400 }}>
                            <Text strong>Select Period (Vilnius Time):</Text><br />
                            <RangePicker
                                value={dateRange}
                                showTime={{ format: 'HH:mm:ss' }}
                                format="YYYY-MM-DD HH:mm:ss"
                                onChange={handleDateChange}
                                style={{ width: '100%' }}
                            />
                        </div>
                        <div>
                            <Button
                                type="primary"
                                onClick={handleRunClick}
                                disabled={loading || !dateRange[0] || !dateRange[1]}
                                style={{ marginTop: 27 }}
                            >
                                {loading ? 'Fetching Data...' : 'Refresh Data'}
                            </Button>
                        </div>
                    </Space>

                    <Tabs
                        defaultActiveKey="1"
                        items={tabsItems}
                        onChange={(key) => {
                            if (key === '1') setActiveCorrelationTabKey('normalized');
                            if (key === '2') setActiveCorrelationTabKey('raw');
                        }}
                    />
                    
                    <antd.Modal
                        title={modalTitle}
                        open={modalVisible}
                        onCancel={handleCancelModal}
                        footer={null}
                        width="80%"
                    >
                        <EChartsVisualization
                            data={modalChartData}
                            yAxisName="Value"
                            loading={false}
                        />
                    </antd.Modal>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(
            React.createElement(AppProvider, null, React.createElement(MainApp))
        );
    </script>
</body>

</html>